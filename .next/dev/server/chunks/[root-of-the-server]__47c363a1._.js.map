{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/alien/Development/tinkertank/tinkertank-market/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nexport const prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    log: ['query', 'error'],\n  });\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf,KAAK;QAAC;QAAS;KAAQ;AACzB;AAEF,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///Users/alien/Development/tinkertank/tinkertank-market/src/types/booking.ts"],"sourcesContent":["import { z } from 'zod'\nimport { EventInput } from '@fullcalendar/core'\nimport { Student } from './student'\nimport { Product } from './product'\nimport { Location } from './location'\n\n// Booking status enum\nexport enum BookingStatus {\n  PENDING = 'PENDING',\n  CONFIRMED = 'CONFIRMED',\n  CANCELLED = 'CANCELLED',\n  COMPLETED = 'COMPLETED',\n  NO_SHOW = 'NO_SHOW'\n}\n\n// Payment status enum\nexport enum PaymentStatus {\n  PENDING = 'PENDING',\n  PAID = 'PAID',\n  PARTIALLY_PAID = 'PARTIALLY_PAID',\n  REFUNDED = 'REFUNDED',\n  FAILED = 'FAILED'\n}\n\n// Event/Booking interface\nexport interface BookingEvent {\n  id: string\n  productId: string\n  product?: Product\n  studentId: string\n  student?: Student\n  locationId: string\n  location?: Location\n  startDateTime: Date\n  endDateTime: Date\n  status: BookingStatus\n  paymentStatus: PaymentStatus\n  totalAmount: number\n  amountPaid: number\n  discountsApplied: string[]\n  specialRequests?: string\n  notes?: string\n  stripePaymentIntentId?: string\n  createdAt: Date\n  updatedAt: Date\n}\n\n// Recurring event template\nexport interface RecurringEventTemplate {\n  id: string\n  productId: string\n  locationId: string\n  startTime: string // HH:MM\n  endTime: string // HH:MM\n  daysOfWeek: number[] // 0 = Sunday, 1 = Monday, etc.\n  startDate: Date\n  endDate?: Date\n  maxOccurrences?: number\n  isActive: boolean\n}\n\n// FullCalendar integration types\nexport interface CalendarEvent extends EventInput {\n  id: string\n  title: string\n  start: Date\n  end: Date\n  backgroundColor?: string\n  borderColor?: string\n  extendedProps: {\n    bookingId?: string\n    productType: string\n    studentName?: string\n    location: string\n    status: BookingStatus\n    paymentStatus: PaymentStatus\n    capacity?: number\n    currentBookings?: number\n  }\n}\n\n// Admin calendar view type\nexport interface AdminCalendarEvent extends CalendarEvent {\n  extendedProps: CalendarEvent['extendedProps'] & {\n    product: Product\n    bookings: BookingEvent[]\n    availableSpots: number\n  }\n}\n\n// Zod schemas\nexport const BookingEventSchema = z.object({\n  id: z.string().min(1),\n  productId: z.string().min(1),\n  studentId: z.string().min(1),\n  locationId: z.string().min(1),\n  startDateTime: z.coerce.date(),\n  endDateTime: z.coerce.date(),\n  status: z.nativeEnum(BookingStatus),\n  paymentStatus: z.nativeEnum(PaymentStatus),\n  totalAmount: z.number().min(0),\n  amountPaid: z.number().min(0).default(0),\n  discountsApplied: z.array(z.string()).default([]),\n  specialRequests: z.string().optional(),\n  notes: z.string().optional(),\n  stripePaymentIntentId: z.string().optional(),\n  createdAt: z.coerce.date(),\n  updatedAt: z.coerce.date(),\n}).refine(\n  (data) => data.endDateTime > data.startDateTime,\n  { message: 'End time must be after start time', path: ['endDateTime'] }\n).refine(\n  (data) => data.amountPaid <= data.totalAmount,\n  { message: 'Amount paid cannot exceed total amount', path: ['amountPaid'] }\n)\n\nexport const RecurringEventTemplateSchema = z.object({\n  id: z.string().min(1),\n  productId: z.string().min(1),\n  locationId: z.string().min(1),\n  startTime: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, 'Invalid time format'),\n  endTime: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, 'Invalid time format'),\n  daysOfWeek: z.array(z.number().min(0).max(6)).min(1, 'At least one day must be selected'),\n  startDate: z.coerce.date(),\n  endDate: z.coerce.date().optional(),\n  maxOccurrences: z.number().min(1).optional(),\n  isActive: z.boolean().default(true),\n}).refine(\n  (data) => !data.endDate || data.endDate > data.startDate,\n  { message: 'End date must be after start date', path: ['endDate'] }\n)\n\nexport const CalendarEventSchema = z.object({\n  id: z.string(),\n  title: z.string(),\n  start: z.coerce.date(),\n  end: z.coerce.date(),\n  backgroundColor: z.string().optional(),\n  borderColor: z.string().optional(),\n  extendedProps: z.object({\n    bookingId: z.string().optional(),\n    productType: z.string(),\n    studentName: z.string().optional(),\n    location: z.string(),\n    status: z.nativeEnum(BookingStatus),\n    paymentStatus: z.nativeEnum(PaymentStatus),\n    capacity: z.number().optional(),\n    currentBookings: z.number().optional(),\n  }),\n})\n\n// Type guards and utilities\nexport const isBookingConfirmed = (booking: BookingEvent): boolean => {\n  return booking.status === BookingStatus.CONFIRMED\n}\n\nexport const isBookingPaid = (booking: BookingEvent): boolean => {\n  return booking.paymentStatus === PaymentStatus.PAID\n}\n\nexport const getBookingStatusColor = (status: BookingStatus): string => {\n  switch (status) {\n    case BookingStatus.CONFIRMED:\n      return '#10B981' // green\n    case BookingStatus.PENDING:\n      return '#F59E0B' // yellow\n    case BookingStatus.CANCELLED:\n      return '#EF4444' // red\n    case BookingStatus.COMPLETED:\n      return '#6366F1' // indigo\n    case BookingStatus.NO_SHOW:\n      return '#6B7280' // gray\n    default:\n      return '#6B7280'\n  }\n}\n\nexport const getPaymentStatusColor = (status: PaymentStatus): string => {\n  switch (status) {\n    case PaymentStatus.PAID:\n      return '#10B981' // green\n    case PaymentStatus.PARTIALLY_PAID:\n      return '#F59E0B' // yellow\n    case PaymentStatus.PENDING:\n      return '#F59E0B' // yellow\n    case PaymentStatus.REFUNDED:\n      return '#6366F1' // indigo\n    case PaymentStatus.FAILED:\n      return '#EF4444' // red\n    default:\n      return '#6B7280'\n  }\n}\n\n// Convert booking to calendar event\nexport const bookingToCalendarEvent = (\n  booking: BookingEvent,\n  product?: Product,\n  student?: Student,\n  location?: Location\n): CalendarEvent => {\n  return {\n    id: booking.id,\n    title: product?.name || 'Unknown Product',\n    start: booking.startDateTime,\n    end: booking.endDateTime,\n    backgroundColor: getBookingStatusColor(booking.status),\n    borderColor: getPaymentStatusColor(booking.paymentStatus),\n    extendedProps: {\n      bookingId: booking.id,\n      productType: product?.type || 'UNKNOWN',\n      studentName: student?.name,\n      location: location?.name || 'Unknown Location',\n      status: booking.status,\n      paymentStatus: booking.paymentStatus,\n      capacity: product?.capacity,\n      currentBookings: 1, // This would be calculated based on other bookings for the same slot\n    },\n  }\n}\n\n// Check if booking can be cancelled\nexport const canCancelBooking = (booking: BookingEvent, hoursBeforeStart = 24): boolean => {\n  if (booking.status === BookingStatus.CANCELLED || booking.status === BookingStatus.COMPLETED) {\n    return false\n  }\n\n  const hoursUntilStart = (booking.startDateTime.getTime() - Date.now()) / (1000 * 60 * 60)\n  return hoursUntilStart >= hoursBeforeStart\n}\n\nexport type BookingInput = z.infer<typeof BookingEventSchema>\nexport type RecurringEventInput = z.infer<typeof RecurringEventTemplateSchema>\nexport type CalendarEventInput = z.infer<typeof CalendarEventSchema>\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 248, "column": 0}, "map": {"version":3,"sources":["file:///Users/alien/Development/tinkertank/tinkertank-market/src/lib/calendar-utils.ts"],"sourcesContent":["import { BookingEvent, CalendarEvent, PaymentStatus } from '@/types/booking'\nimport { Booking, Product, Student, Location } from '@prisma/client'\n\n// Convert Prisma Booking to BookingEvent interface\nexport function prismaBookingToBookingEvent(\n  booking: Booking & {\n    product?: Product | null\n    student?: Student | null \n    location?: Location | null\n  }\n): BookingEvent {\n  return {\n    id: booking.id,\n    productId: booking.productId,\n    product: booking.product || undefined,\n    studentId: booking.studentId,\n    student: booking.student || undefined,\n    locationId: booking.locationId,\n    location: booking.location || undefined,\n    startDateTime: booking.startDate,\n    endDateTime: booking.endDate,\n    status: booking.status,\n    paymentStatus: PaymentStatus.PENDING, // Default since not in Booking model\n    totalAmount: Number(booking.totalPrice),\n    amountPaid: 0, // Default since not in Booking model\n    discountsApplied: [], // Default since not in Booking model\n    specialRequests: booking.notes,\n    notes: booking.notes,\n    createdAt: booking.createdAt,\n    updatedAt: booking.updatedAt,\n  }\n}\n\n// Convert Prisma Booking to CalendarEvent\nexport function prismaBookingToCalendarEvent(\n  booking: Booking & {\n    product?: Product | null\n    student?: Student | null \n    location?: Location | null\n  }\n): CalendarEvent {\n  const bookingEvent = prismaBookingToBookingEvent(booking)\n  \n  return {\n    id: booking.id,\n    title: booking.product?.name || 'Unknown Product',\n    start: booking.startDate,\n    end: booking.endDate,\n    backgroundColor: getBookingStatusColor(booking.status),\n    borderColor: '#3B82F6', // Default blue border\n    extendedProps: {\n      bookingId: booking.id,\n      productType: booking.product?.type || 'UNKNOWN',\n      studentName: booking.student?.name,\n      location: booking.location?.name || 'Unknown Location',\n      status: booking.status,\n      paymentStatus: PaymentStatus.PENDING,\n      capacity: 20, // Default capacity since Prisma Product model doesn't have this field yet\n      currentBookings: 1,\n    },\n  }\n}\n\n// Color mapping for booking status\nfunction getBookingStatusColor(status: string): string {\n  switch (status) {\n    case 'CONFIRMED':\n      return '#10B981' // green\n    case 'PENDING':\n      return '#F59E0B' // yellow\n    case 'CANCELLED':\n      return '#EF4444' // red\n    case 'COMPLETED':\n      return '#6366F1' // indigo\n    case 'NO_SHOW':\n      return '#6B7280' // gray\n    default:\n      return '#6B7280'\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AAIO,SAAS,4BACd,OAIC;IAED,OAAO;QACL,IAAI,QAAQ,EAAE;QACd,WAAW,QAAQ,SAAS;QAC5B,SAAS,QAAQ,OAAO,IAAI;QAC5B,WAAW,QAAQ,SAAS;QAC5B,SAAS,QAAQ,OAAO,IAAI;QAC5B,YAAY,QAAQ,UAAU;QAC9B,UAAU,QAAQ,QAAQ,IAAI;QAC9B,eAAe,QAAQ,SAAS;QAChC,aAAa,QAAQ,OAAO;QAC5B,QAAQ,QAAQ,MAAM;QACtB,eAAe,0IAAa,CAAC,OAAO;QACpC,aAAa,OAAO,QAAQ,UAAU;QACtC,YAAY;QACZ,kBAAkB,EAAE;QACpB,iBAAiB,QAAQ,KAAK;QAC9B,OAAO,QAAQ,KAAK;QACpB,WAAW,QAAQ,SAAS;QAC5B,WAAW,QAAQ,SAAS;IAC9B;AACF;AAGO,SAAS,6BACd,OAIC;IAED,MAAM,eAAe,4BAA4B;IAEjD,OAAO;QACL,IAAI,QAAQ,EAAE;QACd,OAAO,QAAQ,OAAO,EAAE,QAAQ;QAChC,OAAO,QAAQ,SAAS;QACxB,KAAK,QAAQ,OAAO;QACpB,iBAAiB,sBAAsB,QAAQ,MAAM;QACrD,aAAa;QACb,eAAe;YACb,WAAW,QAAQ,EAAE;YACrB,aAAa,QAAQ,OAAO,EAAE,QAAQ;YACtC,aAAa,QAAQ,OAAO,EAAE;YAC9B,UAAU,QAAQ,QAAQ,EAAE,QAAQ;YACpC,QAAQ,QAAQ,MAAM;YACtB,eAAe,0IAAa,CAAC,OAAO;YACpC,UAAU;YACV,iBAAiB;QACnB;IACF;AACF;AAEA,mCAAmC;AACnC,SAAS,sBAAsB,MAAc;IAC3C,OAAQ;QACN,KAAK;YACH,OAAO,UAAU,QAAQ;;QAC3B,KAAK;YACH,OAAO,UAAU,SAAS;;QAC5B,KAAK;YACH,OAAO,UAAU,MAAM;;QACzB,KAAK;YACH,OAAO,UAAU,SAAS;;QAC5B,KAAK;YACH,OAAO,UAAU,OAAO;;QAC1B;YACE,OAAO;IACX;AACF","debugId":null}},
    {"offset": {"line": 325, "column": 0}, "map": {"version":3,"sources":["file:///Users/alien/Development/tinkertank/tinkertank-market/src/app/api/calendar/events/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\nimport { CalendarEvent, AdminCalendarEvent } from '@/types/booking'\nimport { prismaBookingToCalendarEvent } from '@/lib/calendar-utils'\nimport { startOfMonth, endOfMonth, parseISO } from 'date-fns'\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const startParam = searchParams.get('start')\n    const endParam = searchParams.get('end')\n    const viewType = searchParams.get('view') // 'customer' | 'admin'\n    const productType = searchParams.get('productType')\n    const locationId = searchParams.get('locationId')\n\n    // Default to current month if no date range provided\n    const now = new Date()\n    const start = startParam ? parseISO(startParam) : startOfMonth(now)\n    const end = endParam ? parseISO(endParam) : endOfMonth(now)\n\n    // Build where clause\n    const whereClause: any = {\n      startDate: {\n        gte: start,\n        lte: end,\n      },\n    }\n\n    if (productType) {\n      whereClause.product = {\n        type: productType.toUpperCase(),\n      }\n    }\n\n    if (locationId) {\n      whereClause.locationId = locationId\n    }\n\n    // Fetch bookings with related data\n    const bookings = await prisma.booking.findMany({\n      where: whereClause,\n      include: {\n        product: true,\n        student: true,\n        location: true,\n      },\n      orderBy: {\n        startDate: 'asc',\n      },\n    })\n\n    if (viewType === 'admin') {\n      // Group bookings by product/time slot for admin view\n      const eventsMap = new Map<string, AdminCalendarEvent>()\n\n      bookings.forEach((booking) => {\n        const key = `${booking.productId}-${booking.startDate.getTime()}`\n        \n        if (!eventsMap.has(key)) {\n          const calendarEvent = prismaBookingToCalendarEvent(booking)\n          \n          eventsMap.set(key, {\n            ...calendarEvent,\n            extendedProps: {\n              ...calendarEvent.extendedProps,\n              product: booking.product as any,\n              bookings: [booking as any],\n              availableSpots: 20 - 1, // Default capacity since Prisma Product model doesn't have this field yet\n              currentBookings: 1,\n            },\n          } as AdminCalendarEvent)\n        } else {\n          const event = eventsMap.get(key)!\n          event.extendedProps.bookings.push(booking as any)\n          event.extendedProps.currentBookings = (event.extendedProps.currentBookings || 0) + 1\n          event.extendedProps.availableSpots = 20 - event.extendedProps.currentBookings\n        }\n      })\n\n      return NextResponse.json({\n        success: true,\n        events: Array.from(eventsMap.values()),\n      })\n    } else {\n      // Customer view - show individual available slots\n      const events: CalendarEvent[] = bookings.map((booking) =>\n        prismaBookingToCalendarEvent(booking)\n      )\n\n      // Add available time slots (this would typically come from a separate table)\n      // For now, we'll generate some sample available slots\n      const availableSlots = await generateAvailableSlots(start, end, productType)\n      \n      return NextResponse.json({\n        success: true,\n        events: [...events, ...availableSlots],\n      })\n    }\n  } catch (error) {\n    console.error('Error fetching calendar events:', error)\n    return NextResponse.json(\n      { success: false, error: 'Failed to fetch calendar events' },\n      { status: 500 }\n    )\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const data = await request.json()\n    \n    // Create new booking/event\n    const booking = await prisma.booking.create({\n      data: {\n        studentId: data.studentId,\n        productId: data.productId,\n        locationId: data.locationId,\n        startDate: new Date(data.startDateTime),\n        endDate: new Date(data.endDateTime),\n        status: data.status || 'PENDING',\n        totalPrice: data.totalAmount,\n        notes: data.specialRequests || data.notes,\n      },\n      include: {\n        product: true,\n        student: true,\n        location: true,\n      },\n    })\n\n    const calendarEvent = prismaBookingToCalendarEvent(booking)\n\n    return NextResponse.json({\n      success: true,\n      event: calendarEvent,\n      booking,\n    })\n  } catch (error) {\n    console.error('Error creating calendar event:', error)\n    return NextResponse.json(\n      { success: false, error: 'Failed to create calendar event' },\n      { status: 500 }\n    )\n  }\n}\n\n// Helper function to generate available time slots\n// In a real app, this would query a separate availability table\nasync function generateAvailableSlots(\n  start: Date,\n  end: Date,\n  productType?: string | null\n): Promise<CalendarEvent[]> {\n  const slots: CalendarEvent[] = []\n  \n  // Sample available slots for demonstration\n  const sampleProducts = await prisma.product.findMany({\n    where: productType ? { type: productType.toUpperCase() as any } : {},\n    take: 5,\n  })\n\n  const locations = await prisma.location.findMany()\n  \n  // Generate slots for each weekday between start and end\n  const current = new Date(start)\n  while (current <= end) {\n    const dayOfWeek = current.getDay()\n    \n    // Skip weekends for camps\n    if (productType === 'CAMP' && (dayOfWeek === 0 || dayOfWeek === 6)) {\n      current.setDate(current.getDate() + 1)\n      continue\n    }\n\n    // Generate morning and afternoon slots\n    const timeSlots = productType === 'CAMP' \n      ? [{ start: '09:00', end: '15:00' }] // Full day camps\n      : [{ start: '09:00', end: '12:00' }, { start: '13:00', end: '16:00' }] // Half day sessions\n\n    sampleProducts.forEach((product) => {\n      timeSlots.forEach((timeSlot, index) => {\n        const slotStart = new Date(current)\n        const [startHour, startMin] = timeSlot.start.split(':').map(Number)\n        slotStart.setHours(startHour, startMin, 0, 0)\n        \n        const slotEnd = new Date(current)\n        const [endHour, endMin] = timeSlot.end.split(':').map(Number)\n        slotEnd.setHours(endHour, endMin, 0, 0)\n\n        slots.push({\n          id: `available-${product.id}-${current.toISOString().split('T')[0]}-${index}`,\n          title: `${product.name} - Available`,\n          start: slotStart,\n          end: slotEnd,\n          backgroundColor: '#E5F3FF',\n          borderColor: '#3B82F6',\n          extendedProps: {\n            productType: product.type,\n            location: locations[0]?.name || 'Neutral Bay',\n            status: 'AVAILABLE' as any,\n            paymentStatus: 'PENDING' as any,\n            capacity: 20, // Default capacity since Prisma Product model doesn't have this field yet\n            currentBookings: 0,\n          },\n        })\n      })\n    })\n\n    current.setDate(current.getDate() + 1)\n  }\n\n  return slots\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}